-- -- ถ้า schema ยังไม่มี ให้สร้างก่อน
-- CREATE SCHEMA IF NOT EXISTS aods_dev_v2;

-- ตั้ง search_path (เฉพาะ session/connection นี้)
-- SET search_path TO aods_dev_v2;
SET search_path TO aods_dev_v3;

-- ============================================================
-- DROP TABLES (ลบทุกตารางที่เกี่ยวข้อง ถ้าอยาก reset ทั้งหมด)
-- ============================================================
DROP TABLE IF EXISTS
  recipients,
  recipient_links,
  report_send_history,
  scheduled_reports,
  reports,
  alert_note_history,
  alert_logs,
  alerts,
  footages,
  maintenance_history,
  camera_permissions,
  camera_detection_settings,
  camera_performance_daily,
  camera_logs,
  cameras,
  notification_thresholds,
  event_priority,
  alert_escalation,
  notification_recipients,
  global_detection_settings,
  events,
  locations,
  auth_activity_logs,
  users,
  roles
CASCADE;

---------------------------------------------------------------------------
---------------------------------[ Tables ]--------------------------------
---------------------------------------------------------------------------

---------------------------------[ user ]---------------------------------

CREATE TABLE IF NOT EXISTS roles (
  rol_id           INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,

  rol_name         VARCHAR(32) NOT NULL UNIQUE,
  rol_access_level INTEGER NOT NULL DEFAULT 1,

  rol_created_at   TIMESTAMP  NOT NULL DEFAULT CURRENT_TIMESTAMP,
  rol_updated_at   TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  rol_is_use       BOOLEAN NOT NULL DEFAULT TRUE
);

CREATE TABLE IF NOT EXISTS users (
  usr_id          INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  usr_rol_id      INTEGER NOT NULL REFERENCES roles(rol_id) ON DELETE CASCADE,

  usr_username    VARCHAR(32)  NOT NULL UNIQUE,
  usr_email       VARCHAR(64) NOT NULL UNIQUE,
  usr_password    VARCHAR(255) NOT NULL,
  usr_name        VARCHAR(32),  
  usr_phone       VARCHAR(10),
  usr_profile     VARCHAR(255),

  usr_created_at  TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  usr_updated_at  TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  usr_is_use      BOOLEAN NOT NULL DEFAULT TRUE
);

CREATE TABLE IF NOT EXISTS auth_activity_logs (
  aal_id          INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  aal_usr_id      INTEGER NOT NULL REFERENCES users(usr_id) ON DELETE CASCADE,

  aal_action      VARCHAR(64) NOT NULL,

  aal_created_at  TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

---------------------------------[ Location ]---------------------------------

CREATE TABLE IF NOT EXISTS locations (
  loc_id          INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,

  loc_name        VARCHAR(32) NOT NULL,

  loc_created_at  TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  loc_updated_at  TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  loc_is_use      BOOLEAN NOT NULL DEFAULT TRUE
);

---------------------------------[ Event ]---------------------------------

CREATE TABLE IF NOT EXISTS events (
  evt_id          INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,

  evt_icon        VARCHAR(32) NOT NULL,
  evt_name        VARCHAR(32) UNIQUE NOT NULL,
  evt_description TEXT,

  evt_created_at  TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  evt_updated_at  TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  evt_is_use      BOOLEAN NOT NULL DEFAULT TRUE
);

CREATE TABLE IF NOT EXISTS global_detection_settings (
  gds_id          INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  gds_evt_id      INTEGER NOT NULL UNIQUE REFERENCES events(evt_id) ON DELETE CASCADE,

  gds_sensitivity VARCHAR(16) NOT NULL DEFAULT 'high' CHECK (gds_sensitivity IN ('critical','high','medium','low')),
  gds_priority    VARCHAR(16) NOT NULL DEFAULT 'high' CHECK (gds_priority IN ('critical','high','medium','low')),
  gds_status      BOOLEAN NOT NULL DEFAULT TRUE,

  gds_created_at  TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  gds_updated_at  TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

---------------------------------[ Camera ]---------------------------------

CREATE TABLE IF NOT EXISTS cameras (
  cam_id           INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  cam_created_by   INTEGER NOT NULL REFERENCES users(usr_id) ON DELETE CASCADE,
  cam_loc_id       INTEGER  NOT NULL REFERENCES locations(loc_id) ON DELETE CASCADE,

  cam_name         VARCHAR(32)  NOT NULL,
  cam_source_type  VARCHAR(16) NOT NULL DEFAULT 'url' CHECK (cam_source_type IN ('url', 'address')),
  cam_source_value VARCHAR(255) NOT NULL,
  cam_type         VARCHAR(32) NOT NULL DEFAULT 'fixed' CHECK (cam_type IN ('fixed','ptz','panoramic','thermal')),
  -- cam_resolution   VARCHAR(16)  NOT NULL,
  cam_status       BOOLEAN  NOT NULL DEFAULT TRUE,
  cam_description  TEXT,

  cam_created_at   TIMESTAMP  NOT NULL DEFAULT CURRENT_TIMESTAMP,
  cam_updated_at   TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  cam_is_use       BOOLEAN  NOT NULL DEFAULT TRUE
);

CREATE TABLE IF NOT EXISTS camera_logs (
  clg_id          INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  clg_usr_id      INTEGER NOT NULL REFERENCES users(usr_id) ON DELETE CASCADE,
  clg_cam_id      INTEGER NOT NULL REFERENCES cameras(cam_id) ON DELETE CASCADE,

  clg_action      VARCHAR(32) NOT NULL DEFAULT 'Installed',

  clg_created_at  TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE IF NOT EXISTS camera_performance_daily (
    cpd_id              INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    cpd_cam_id          INT NOT NULL REFERENCES cameras(cam_id) ON DELETE CASCADE,

    cpd_date            DATE NOT NULL,
    -- cpd_health          DECIMAL(5,2) NOT NULL,
    cpd_video_quality   DECIMAL(5,2) NOT NULL,
    cpd_network_latency SMALLINT  NOT NULL,

    cpd_created_at      TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    cpd_is_use          BOOLEAN NOT NULL DEFAULT TRUE,

    UNIQUE (cpd_cam_id, cpd_date)
);

CREATE TABLE IF NOT EXISTS camera_detection_settings (
  cds_id          INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  cds_evt_id      INTEGER NOT NULL REFERENCES events(evt_id) ON DELETE CASCADE,
  cds_cam_id      INTEGER NOT NULL REFERENCES cameras(cam_id) ON DELETE CASCADE,

  cds_sensitivity VARCHAR(16) NOT NULL DEFAULT 'high' CHECK (cds_sensitivity IN ('critical','high','medium','low')),
  cds_priority    VARCHAR(16) NOT NULL DEFAULT 'high' CHECK (cds_priority IN ('critical','high','medium','low')),
  cds_status      BOOLEAN NOT NULL DEFAULT TRUE,

  cds_created_at  TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  cds_updated_at  TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  cds_is_use      BOOLEAN NOT NULL DEFAULT TRUE,

  UNIQUE (cds_evt_id, cds_cam_id)
);

CREATE TABLE IF NOT EXISTS camera_permissions (
  cap_id           INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  cap_cam_id       INTEGER NOT NULL UNIQUE REFERENCES cameras(cam_id) ON DELETE CASCADE,

  cap_require_auth BOOLEAN NOT NULL DEFAULT TRUE,
  cap_restrict     BOOLEAN NOT NULL DEFAULT TRUE,
  cap_log          BOOLEAN NOT NULL DEFAULT TRUE,

  cap_created_at  TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  cap_updated_at  TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  cap_is_use      BOOLEAN NOT NULL DEFAULT TRUE
);

CREATE TABLE IF NOT EXISTS maintenance_history (
  mnt_id        INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  mnt_cam_id    INTEGER NOT NULL REFERENCES cameras(cam_id) ON DELETE CASCADE,

  mnt_date      DATE NOT NULL,
  mnt_type      VARCHAR(32) NOT NULL DEFAULT 'installation' CHECK (mnt_type IN ('installation','repair','routine check', 'upgrade', 'replacement', 'inspection', 'configuration', 'other')),
  mnt_technician VARCHAR(32) NOT NULL,
  mnt_note       TEXT,

  mnt_created_at  TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  mnt_updated_at  TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  mnt_is_use      BOOLEAN NOT NULL DEFAULT TRUE
);

CREATE TABLE IF NOT EXISTS footages (
  fgt_id        INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  fgt_cam_id    INTEGER NOT NULL REFERENCES cameras(cam_id) ON DELETE CASCADE,

  fgt_path      VARCHAR(255) NOT NULL,

  fgt_created_at  TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  fgt_is_use      BOOLEAN NOT NULL DEFAULT TRUE
);

---------------------------------[ Alert ]---------------------------------

CREATE TABLE IF NOT EXISTS alerts (
  alr_id          INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  alr_created_by  INTEGER NOT NULL REFERENCES users(usr_id) ON DELETE CASCADE,
  alr_cam_id      INTEGER NOT NULL REFERENCES cameras(cam_id) ON DELETE CASCADE,
  alr_fgt_id      INTEGER NOT NULL REFERENCES footages(fgt_id) ON DELETE CASCADE,
  alr_evt_id      INTEGER NOT NULL REFERENCES events(evt_id) ON DELETE CASCADE,

  alr_severity    VARCHAR(16) NOT NULL DEFAULT 'critical' CHECK (alr_severity IN ('critical','high','medium','low')),
  alr_status      VARCHAR(16) NOT NULL DEFAULT 'active' CHECK (alr_status IN ('active','resolved','dismissed')),
  alr_description TEXT,
  alr_reason      TEXT, -- 2025-10-13

  alr_created_at  TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  alr_updated_at  TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  alr_is_use      BOOLEAN NOT NULL DEFAULT TRUE
);

CREATE TABLE IF NOT EXISTS alert_logs (
  alg_id          INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  alg_usr_id      INTEGER NOT NULL REFERENCES users(usr_id) ON DELETE CASCADE,
  alg_alr_id      INTEGER NOT NULL REFERENCES alerts(alr_id) ON DELETE CASCADE,

  alg_action  VARCHAR(64) NOT NULL DEFAULT 'Generated',

  alg_created_at  TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE IF NOT EXISTS alert_note_history (
  anh_id          INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  anh_usr_id      INTEGER NOT NULL REFERENCES users(usr_id) ON DELETE CASCADE,
  anh_alr_id      INTEGER NOT NULL REFERENCES alerts(alr_id) ON DELETE CASCADE,

  anh_note        TEXT  NOT NULL,

  anh_created_at  TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  anh_updated_at  TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  anh_is_use      BOOLEAN NOT NULL DEFAULT TRUE
);

---------------------------------[ Notification ]---------------------------------

CREATE TABLE notification_thresholds (
    nth_id        INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,

    nth_type      VARCHAR(16) NOT NULL CHECK (nth_type IN ('in_app','email')),
    nth_critical  BOOLEAN DEFAULT FALSE,
    nth_high      BOOLEAN DEFAULT FALSE,
    nth_medium    BOOLEAN DEFAULT FALSE,
    nth_low       BOOLEAN DEFAULT FALSE
);

CREATE TABLE event_priority (
    epr_id           INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    epr_evt_id       INTEGER NOT NULL UNIQUE REFERENCES events(evt_id) ON DELETE CASCADE,

    epr_priority     VARCHAR(16) CHECK (epr_priority IN ('critical','high','medium','low'))
);

CREATE TABLE alert_escalation (
    aes_id           INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,

    aes_severity     VARCHAR(16) CHECK (aes_severity IN ('critical','high','medium','low')),
    aes_escalate_min INTEGER DEFAULT 5
);

CREATE TABLE notification_recipients (
    nrc_id           INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    nrc_rol_id       INTEGER NOT NULL REFERENCES roles(rol_id) ON DELETE CASCADE,  

    nrc_enable       BOOLEAN DEFAULT TRUE
);

---------------------------------[ Reports ]---------------------------------

CREATE TABLE IF NOT EXISTS reports (
  rpt_id         INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,

  rpt_name        VARCHAR(32) NOT NULL,
  rpt_template    VARCHAR(16) NOT NULL DEFAULT 'general' CHECK (rpt_template IN ('general', 'alert', 'performance')),
  rpt_type        VARCHAR(16) NOT NULL DEFAULT 'pdf' CHECK (rpt_type  IN ('pdf')),
  rpt_range_start DATE NOT NULL,
  rpt_range_end   DATE NOT NULL,
  rpt_description TEXT,
  rpt_path        VARCHAR(255) NOT NULL,

  rpt_created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  rpt_updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE IF NOT EXISTS scheduled_reports (
  scr_id          INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  scr_rpt_id     INTEGER NOT NULL REFERENCES reports(rpt_id) ON DELETE CASCADE,
  
  scr_frequency   VARCHAR(16) NOT NULL DEFAULT 'weekly' CHECK (scr_frequency IN ('daily','3 days','5 days','monday','tuesday','wednesday','thursday','friday','saturday','sunday','weekly','monthly','quarterly')),
  scr_time        TIME NOT NULL DEFAULT '00:00:00',

  scr_created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  scr_updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  scr_is_use     BOOLEAN NOT NULL DEFAULT TRUE
);

CREATE TABLE IF NOT EXISTS report_send_history (
  rsh_id         INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  rsh_scr_id     INTEGER NOT NULL REFERENCES scheduled_reports(scr_id) ON DELETE CASCADE,

  rsh_status     VARCHAR(16) NOT NULL DEFAULT 'processing' CHECK (rsh_status IN ('success','processing','failed')),

  rsh_created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

---------------------------------[ Recipients ]---------------------------------

CREATE TABLE IF NOT EXISTS recipients (
  rcp_id         INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,

  rcp_usr_id    INTEGER REFERENCES users(usr_id),
  rcp_email     VARCHAR(64),

  rcp_created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,

  CONSTRAINT chk_rcp_recipient CHECK (
    rcp_usr_id IS NOT NULL OR rcp_email IS NOT NULL
  )
);

CREATE TABLE IF NOT EXISTS recipient_links (
  rln_id        INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  rln_rcp_id    INTEGER NOT NULL REFERENCES recipients(rcp_id) ON DELETE CASCADE,

  rln_entity    VARCHAR(32) NOT NULL,   -- ชื่อประเภท entity เช่น 'scheduled_report', 'alert'
  rln_entity_id INTEGER NOT NULL,       -- รหัสของ entity นั้น (id ของตารางต้นทาง)

  rln_created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

---------------------------------------------------------------------------
---------------------------------[ Indexs ]--------------------------------
---------------------------------------------------------------------------

---------------------------[ Extensions สำหรับ Index ]----------------------

-- ใช้งาน GIN trigram สำหรับค้นหา ILIKE/partial match
CREATE EXTENSION IF NOT EXISTS pg_trgm;
-- ใช้งาน GiST บนชนิดช่วงเวลา (daterange) สำหรับ query overlap
CREATE EXTENSION IF NOT EXISTS btree_gist;


---------------------------------[ Users / Roles ]-------------------------

-- Users: ค้นหา ILIKE/partial ตามชื่อ
CREATE INDEX IF NOT EXISTS idx_users_name_trgm
  ON users USING GIN (usr_name gin_trgm_ops);

-- Users: ค้นหา ILIKE/partial ตาม username
CREATE INDEX IF NOT EXISTS idx_users_username_trgm
  ON users USING GIN (usr_username gin_trgm_ops);

-- Users: ค้นหา ILIKE/partial ตามอีเมล
CREATE INDEX IF NOT EXISTS idx_users_email_trgm
  ON users USING GIN (usr_email gin_trgm_ops);

-- Auth Logs: กรองตามผู้ใช้ + เรียงเวลาย้อนหลังใน index เดียว (หน้า activity ต่อ user)
CREATE INDEX IF NOT EXISTS idx_aal_user_created_desc
  ON auth_activity_logs(aal_usr_id, aal_created_at DESC);

-- Auth Logs: ตาราง append-only ขนาดใหญ่ → ใช้ BRIN ลด I/O เมื่อสแกนตามเวลา
CREATE INDEX IF NOT EXISTS brin_aal_created_at
  ON auth_activity_logs USING BRIN (aal_created_at)
  WITH (pages_per_range = 64, autosummarize = on);


---------------------------------[ Location / Event ]----------------------

-- Locations: ค้นหา ILIKE/partial ตามชื่อ
CREATE INDEX IF NOT EXISTS idx_locations_name_trgm
  ON locations USING GIN (loc_name gin_trgm_ops);

-- Events: ค้นหา ILIKE/partial ตามชื่อ
CREATE INDEX IF NOT EXISTS idx_events_name_trgm
  ON events USING GIN (evt_name gin_trgm_ops);


---------------------------------[ Cameras ]--------------------------------

-- Cameras: ค้นหา ILIKE/partial ตามชื่อ
CREATE INDEX IF NOT EXISTS idx_cameras_name_trgm
  ON cameras USING GIN (cam_name gin_trgm_ops);

-- Cameras: ค้นหา ILIKE/partial ตามแหล่งสัญญาณ
CREATE INDEX IF NOT EXISTS idx_cameras_source_value_trgm
  ON cameras USING GIN (cam_source_value gin_trgm_ops);

-- Cameras: หน้า list ต่อสถานที่ → กรอง loc + เรียงใหม่สุด
CREATE INDEX IF NOT EXISTS idx_cameras_loc_created_desc
  ON cameras(cam_loc_id, cam_created_at DESC);

-- Cameras: หน้า list ต่อผู้สร้าง → กรองผู้สร้าง + เรียงใหม่สุด
CREATE INDEX IF NOT EXISTS idx_cameras_creator_created_desc
  ON cameras(cam_created_by, cam_created_at DESC);

-- Cameras: ตารางโตตามเวลา → ใช้ BRIN เร่งสแกนช่วงเวลา
CREATE INDEX IF NOT EXISTS brin_cameras_created_at
  ON cameras USING BRIN (cam_created_at)
  WITH (pages_per_range = 64, autosummarize = on);


-------------------------[ Camera Logs / Performance / Settings ]-----------

-- Camera Logs: ต่อกล้อง + เรียงเวลาย้อนหลัง (ไทม์ไลน์ของกล้อง)
CREATE INDEX IF NOT EXISTS idx_clg_camera_created_desc
  ON camera_logs(clg_cam_id, clg_created_at DESC);

-- Camera Logs: append-only → BRIN ตามเวลา
CREATE INDEX IF NOT EXISTS brin_clg_created_at
  ON camera_logs USING BRIN (clg_created_at)
  WITH (pages_per_range = 64, autosummarize = on);

-- Camera Performance Daily: ต่อกล้อง + เรียงใหม่สุด (ดูค่าล่าสุดของกล้อง)
CREATE INDEX IF NOT EXISTS idx_cpd_camera_created_desc
  ON camera_performance_daily(cpd_cam_id, cpd_created_at DESC);

-- Camera Performance Daily: ใช้คู่ is_use + date (รายงานช่วงวัน แต่ต้องกรอง active)
CREATE INDEX IF NOT EXISTS idx_cpd_is_use_date
  ON camera_performance_daily(cpd_is_use, cpd_date);

-- Camera Detection Settings: ดึงค่า active ต่อกล้องได้เร็วขึ้น
CREATE INDEX IF NOT EXISTS idx_cds_cam_status
  ON camera_detection_settings(cds_cam_id, cds_status);


-------------------------------[ Camera Permissions ]-----------------------

-- หมายเหตุ: cap_cam_id เป็น UNIQUE อยู่แล้ว (มี index อัตโนมัติ)
-- ถ้าเผลอสร้าง idx_cap_camera ซ้ำไว้ สามารถลบออกได้:
-- DROP INDEX IF EXISTS idx_cap_camera;


---------------------------------[ Maintenance ]----------------------------

-- Maintenance: ค้นหาช่างแบบ ILIKE/partial (หาชื่อช่าง)
CREATE INDEX IF NOT EXISTS idx_mnt_technician_trgm
  ON maintenance_history USING GIN (mnt_technician gin_trgm_ops);

-- Maintenance: ต่อกล้อง + เรียงเวลาย้อนหลัง (ไทม์ไลน์งานซ่อมของกล้อง)
CREATE INDEX IF NOT EXISTS idx_mnt_camera_created_desc
  ON maintenance_history(mnt_cam_id, mnt_created_at DESC);

-- Maintenance: append-only → BRIN ตามเวลา
CREATE INDEX IF NOT EXISTS brin_mnt_created_at
  ON maintenance_history USING BRIN (mnt_created_at)
  WITH (pages_per_range = 64, autosummarize = on);


---------------------------------[ Footages ]-------------------------------

-- Footages: ค้นหา path แบบ ILIKE/partial (พาธยาว/มีโฟลเดอร์)
CREATE INDEX IF NOT EXISTS idx_fgt_path_trgm
  ON footages USING GIN (fgt_path gin_trgm_ops);

-- Footages: ต่อกล้อง + เรียงเวลาย้อนหลัง
CREATE INDEX IF NOT EXISTS idx_fgt_camera_created_desc
  ON footages(fgt_cam_id, fgt_created_at DESC);

-- Footages: append-only → BRIN ตามเวลา
CREATE INDEX IF NOT EXISTS brin_fgt_created_at
  ON footages USING BRIN (fgt_created_at)
  WITH (pages_per_range = 64, autosummarize = on);


---------------------------------[ Alerts ]---------------------------------

-- Alerts: ต่อกล้อง + สถานะ + เรียงใหม่สุด (หน้าแดชบอร์ดหลัก) เฉพาะที่ใช้งาน
CREATE INDEX IF NOT EXISTS idx_alerts_cam_status_recent
  ON alerts(alr_cam_id, alr_status, alr_created_at DESC)
  WHERE alr_is_use;

-- Alerts: ต่อ event + เรียงใหม่สุด (สรุปตามประเภทเหตุการณ์) เฉพาะที่ใช้งาน
CREATE INDEX IF NOT EXISTS idx_alerts_event_recent
  ON alerts(alr_evt_id, alr_created_at DESC)
  WHERE alr_is_use;

-- Alerts: ต่อผู้สร้าง + เรียงใหม่สุด (ติดตามผู้ใช้ที่สร้าง/รับผิดชอบ) เฉพาะที่ใช้งาน
CREATE INDEX IF NOT EXISTS idx_alerts_creator_recent
  ON alerts(alr_created_by, alr_created_at DESC)
  WHERE alr_is_use;

-- Alerts: ตารางใหญ่โตตามเวลา → BRIN ช่วยสแกนเร็วมาก
CREATE INDEX IF NOT EXISTS brin_alerts_created_at
  ON alerts USING BRIN (alr_created_at)
  WITH (pages_per_range = 64, autosummarize = on);


---------------------------[ Alert Logs / Note History ]--------------------

-- Alert Logs: ต่อ alert + เรียงเวลาย้อนหลัง (ประวัติการจัดการ)
CREATE INDEX IF NOT EXISTS idx_alg_alert_created_desc
  ON alert_logs(alg_alr_id, alg_created_at DESC);

-- Note History: ต่อ alert + เรียงเวลาย้อนหลัง (ไทม์ไลน์โน้ต)
CREATE INDEX IF NOT EXISTS idx_anh_alert_created_desc
  ON alert_note_history(anh_alr_id, anh_created_at DESC);

-- Alert Logs: append-only → BRIN
CREATE INDEX IF NOT EXISTS brin_alg_created_at
  ON alert_logs USING BRIN (alg_created_at)
  WITH (pages_per_range = 64, autosummarize = on);

-- Note History: append-only → BRIN
CREATE INDEX IF NOT EXISTS brin_anh_created_at
  ON alert_note_history USING BRIN (anh_created_at)
  WITH (pages_per_range = 64, autosummarize = on);


---------------------------------[ Notification ]---------------------------

-- Notification Recipients: filter enable + join role (เฉพาะที่เปิดใช้งาน)
CREATE INDEX IF NOT EXISTS idx_nrc_enable_role
  ON notification_recipients(nrc_enable, nrc_rol_id)
  WHERE nrc_enable;


---------------------------------[ Reports / Schedules ]--------------------

-- Reports: ช่วงวันที่แบบ overlap (ค้นหาทับซ้อนช่วงเวลา) ใช้ GiST กับ daterange
CREATE INDEX IF NOT EXISTS gist_reports_range
  ON reports USING GIST (daterange(rpt_range_start, rpt_range_end, '[]'));

-- Reports: กรอง template + เรียงใหม่สุด (หน้า list รายงานต่อ template)
CREATE INDEX IF NOT EXISTS idx_rpt_template_created_desc
  ON reports(rpt_template, rpt_created_at DESC);

-- Report Send History: ต่อ schedule + เรียงเวลาย้อนหลัง
CREATE INDEX IF NOT EXISTS idx_rsh_schedule_created_desc
  ON report_send_history(rsh_scr_id, rsh_created_at DESC);

-- Report Send History: ตารางโตเร็ว → BRIN ตามเวลา
CREATE INDEX IF NOT EXISTS brin_rsh_created_at
  ON report_send_history USING BRIN (rsh_created_at)
  WITH (pages_per_range = 64, autosummarize = on);


---------------------------------[ Recipients / Links ]---------------------

-- Recipients: ค้นหาอีเมลแบบ ILIKE/partial
CREATE INDEX IF NOT EXISTS idx_rcp_email_trgm
  ON recipients USING GIN (rcp_email gin_trgm_ops);

-- Recipient Links: ต่อ recipient + เรียงใหม่สุด (ดูไทม์ไลน์การเชื่อมโยง)
CREATE INDEX IF NOT EXISTS idx_rln_recipient_created_desc
  ON recipient_links(rln_rcp_id, rln_created_at DESC);

---------------------------------------------------------------------------
---------------------------------[ Views ]--------------------------------
---------------------------------------------------------------------------

---------------------------------[ Notification Emails ]--------------------------------
CREATE OR REPLACE VIEW v_notification_emails AS
SELECT
  r.rcp_id,
  COALESCE(u.usr_email, r.rcp_email)                        AS email,
  COALESCE(u.usr_name, u.usr_username, NULL)                AS display_name,
  (u.usr_id IS NOT NULL
     OR EXISTS (SELECT 1 FROM users ux WHERE ux.usr_email = r.rcp_email)
  )                                                         AS is_internal,
  rl.rln_entity,
  rl.rln_entity_id,
  r.rcp_created_at
FROM recipient_links rl
JOIN recipients r        ON r.rcp_id  = rl.rln_rcp_id
LEFT JOIN users u        ON u.usr_id  = r.rcp_usr_id
WHERE rl.rln_entity <> 'scheduled_report'
ORDER BY r.rcp_created_at DESC;

---------------------------------[ Scheduled Report Emails ]--------------------------------
CREATE OR REPLACE VIEW v_scheduled_report_emails AS
SELECT
  r.rcp_id,
  COALESCE(u.usr_email, r.rcp_email)                        AS email,
  COALESCE(u.usr_name, u.usr_username, NULL)                AS display_name,
  (u.usr_id IS NOT NULL
     OR EXISTS (SELECT 1 FROM users ux WHERE ux.usr_email = r.rcp_email)
  )                                                         AS is_internal,

  -- บอกว่าเป็นของ schedule ไหน / report ไหน
  scr.scr_id                                                AS schedule_id,
  rpt.rpt_id                                                AS report_id,
  rpt.rpt_name                                              AS report_name,

  -- เผื่ออยากดู metadata เพิ่มเติม
  scr.scr_frequency,
  scr.scr_time,
  r.rcp_created_at
FROM recipient_links rl
JOIN recipients r          ON r.rcp_id  = rl.rln_rcp_id
LEFT JOIN users u          ON u.usr_id  = r.rcp_usr_id
JOIN scheduled_reports scr ON scr.scr_id = rl.rln_entity_id
JOIN reports rpt           ON rpt.rpt_id = scr.scr_rpt_id
WHERE rl.rln_entity = 'scheduled_report'
ORDER BY r.rcp_created_at DESC;

---------------------------------[ Camera Status Cards ]--------------------------------
CREATE OR REPLACE VIEW v_camera_summary AS
WITH latest_mnt AS (
  SELECT DISTINCT ON (m.mnt_cam_id)
         m.mnt_cam_id,
         m.mnt_type,
         m.mnt_date,
         m.mnt_created_at
  FROM maintenance_history m
  WHERE m.mnt_is_use = TRUE
  ORDER BY m.mnt_cam_id, m.mnt_date DESC, m.mnt_created_at DESC
)
SELECT
  COUNT(*)::INT                                       AS total,
  COUNT(*) FILTER (WHERE c.cam_status = TRUE)::INT     AS active,
  COUNT(*) FILTER (WHERE c.cam_status = FALSE)::INT    AS inactive,
  COUNT(*) FILTER (
    WHERE lm.mnt_type = 'repair'
  )::INT                                               AS total_repair
FROM cameras c
LEFT JOIN latest_mnt lm ON lm.mnt_cam_id = c.cam_id
WHERE c.cam_is_use = TRUE;

---------------------------------[ Alert Status Cards ]--------------------------------
CREATE OR REPLACE VIEW v_alerts_summary AS
SELECT
  COUNT(*)::INT                                                            AS total,
  COUNT(*) FILTER (WHERE alr_status = 'active')::INT                       AS active,
  COUNT(*) FILTER (WHERE alr_status = 'resolved')::INT                     AS resolved,
  COUNT(*) FILTER (WHERE alr_status = 'dismissed')::INT                    AS dismiss,
  COUNT(*) FILTER (WHERE alr_severity = 'critical')::INT                   AS total_critical,
  COUNT(*) FILTER (WHERE alr_severity = 'high')::INT                       AS total_high,
  COUNT(*) FILTER (WHERE alr_severity = 'medium')::INT                     AS total_medium,
  COUNT(*) FILTER (WHERE alr_severity = 'low')::INT                        AS total_low
FROM alerts
WHERE alr_is_use = TRUE;

---------------------------------[ Report Status Cards ]--------------------------------
CREATE OR REPLACE VIEW v_reports_summary AS
SELECT
  COUNT(*)::INT                                                        AS total,
  COUNT(*) FILTER (WHERE rsh_status = 'success')::INT                  AS success,
  COUNT(*) FILTER (WHERE rsh_status = 'processing')::INT               AS processing,
  COUNT(*) FILTER (WHERE rsh_status = 'failed')::INT                   AS failed
FROM report_send_history;

---------------------------------[ Cameras View ]--------------------------------
CREATE OR REPLACE VIEW v_cameras_overview AS
WITH latest_mnt AS (
  SELECT DISTINCT ON (m.mnt_cam_id)
         m.mnt_cam_id,
         m.mnt_type,
         m.mnt_technician,
         m.mnt_date,
         m.mnt_created_at
  FROM maintenance_history m
  WHERE m.mnt_is_use = TRUE
  ORDER BY m.mnt_cam_id, m.mnt_date DESC, m.mnt_created_at DESC
)
SELECT
  c.cam_id             AS camera_id,
  c.cam_name           AS camera_name,
  c.cam_type           AS camera_type,
  c.cam_status         AS camera_status,
  l.loc_name           AS location_name,
  c.cam_source_type    AS source_type,
  c.cam_source_value   AS source_value,
  c.cam_description    AS description,
  lm.mnt_date          AS date_last_maintenance,
  lm.mnt_type          AS maintenance_type
FROM cameras c
LEFT JOIN locations l ON l.loc_id = c.cam_loc_id
LEFT JOIN latest_mnt lm ON lm.mnt_cam_id = c.cam_id
WHERE c.cam_is_use = TRUE
ORDER BY c.cam_id ASC;

---------------------------------[ Events View ]--------------------------------
CREATE OR REPLACE VIEW v_events_overview AS
SELECT
  e.evt_id             AS event_id,
  e.evt_name           AS event_name,
  e.evt_icon           AS icon_name,
  e.evt_description    AS description,
  g.gds_status         AS status,
  g.gds_sensitivity    AS sensitivity,
  g.gds_priority       AS priority,
  e.evt_created_at     AS created_at,
  e.evt_is_use         AS is_use
FROM events e
LEFT JOIN global_detection_settings g 
       ON g.gds_evt_id = e.evt_id
WHERE e.evt_is_use = TRUE
ORDER BY e.evt_id ASC;

---------------------------------[ Active Event In Cameras ]--------------------------------
CREATE OR REPLACE VIEW v_events_in_cameras AS
SELECT
  e.evt_id          AS event_id,
  e.evt_name        AS event_name,
  c.cam_id          AS camera_id,
  c.cam_name        AS camera_name,
  l.loc_name        AS location_name,
  c.cam_status      AS camera_status
FROM camera_detection_settings cds
JOIN events   e ON e.evt_id   = cds.cds_evt_id
JOIN cameras  c ON c.cam_id   = cds.cds_cam_id
LEFT JOIN locations l ON l.loc_id = c.cam_loc_id
WHERE e.evt_is_use   = TRUE      -- ใช้งานอยู่ในระบบ (events)
  AND cds.cds_is_use = TRUE      -- mapping event↔camera ยังใช้งาน
  AND c.cam_is_use   = TRUE      -- กล้องยังใช้งาน
ORDER BY e.evt_id ASC, c.cam_id ASC;

---------------------------------[ Camera Permissions ]--------------------------------
CREATE OR REPLACE VIEW v_camera_permissions AS
SELECT
  c.cam_id                         AS camera_id,
  c.cam_name                       AS camera_name,
  p.cap_require_auth               AS require_authorization,
  p.cap_restrict                   AS restrict_role,
  p.cap_log                        AS log_access_attempts
FROM cameras c
JOIN camera_permissions p
  ON p.cap_cam_id = c.cam_id
WHERE c.cam_is_use = TRUE
  AND p.cap_is_use = TRUE
ORDER BY c.cam_id ASC;

---------------------------------[ Alerts View ]--------------------------------
CREATE OR REPLACE VIEW v_alerts_overview AS
SELECT
  a.alr_severity          AS severity,
  a.alr_id                AS alert_id,
  a.alr_created_at        AS created_at,
  c.cam_id                AS camera_id,
  c.cam_name              AS camera_name,
  e.evt_icon              AS event_icon,
  e.evt_name              AS event_name,
  l.loc_name              AS location_name,
  a.alr_status            AS alert_status,
  f.fgt_id                AS footage_id,
  f.fgt_path              AS footage_path,
  COALESCE(u.usr_name, u.usr_username, 'System') AS created_by
FROM alerts a
JOIN cameras   c ON c.cam_id = a.alr_cam_id
LEFT JOIN locations l ON l.loc_id = c.cam_loc_id
JOIN events    e ON e.evt_id = a.alr_evt_id
JOIN footages  f ON f.fgt_id = a.alr_fgt_id
LEFT JOIN users u ON u.usr_id = a.alr_created_by
WHERE a.alr_is_use = TRUE
ORDER BY 
  CASE WHEN a.alr_status = 'active' THEN 1 ELSE 2 END,  -- active ก่อน
  a.alr_created_at DESC;       
  
---------------------------------[ Camera Performance ]--------------------------------
  CREATE OR REPLACE VIEW v_camera_performance_today AS
SELECT
  cpd.cpd_id              AS performance_id,
  cpd.cpd_cam_id          AS camera_id,
  c.cam_name              AS camera_name,
  l.loc_name              AS location_name,
  cpd.cpd_date            AS record_date,
  cpd.cpd_video_quality   AS video_quality,
  cpd.cpd_network_latency AS network_latency,
  cpd.cpd_created_at      AS created_at
FROM camera_performance_daily cpd
JOIN cameras c
  ON c.cam_id = cpd.cpd_cam_id
LEFT JOIN locations l
  ON l.loc_id = c.cam_loc_id
WHERE cpd.cpd_is_use = TRUE
  AND c.cam_is_use = TRUE
  AND cpd.cpd_date = CURRENT_DATE
ORDER BY cpd.cpd_cam_id ASC;                        -- ล่าสุดก่อน

-----------------------------------------------------------------------------
---------------------------------[ Triggers ]--------------------------------
-----------------------------------------------------------------------------

/* ============================================================
   ============  Generic: touch *_updated_at  =================
   ============================================================ */

/* ============================================================
   ===========  On events INSERT: fill GDS (global)  ===========
   ============================================================ */

-- อัปเดตฟังก์ชัน touch ให้รองรับตาราง global_detection_settings ด้วย
CREATE OR REPLACE FUNCTION trg_touch_updated_at()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
  IF TG_TABLE_NAME = 'users' THEN
    NEW.usr_updated_at := CURRENT_TIMESTAMP;
  ELSIF TG_TABLE_NAME = 'roles' THEN
    NEW.rol_updated_at := CURRENT_TIMESTAMP;
  ELSIF TG_TABLE_NAME = 'cameras' THEN
    NEW.cam_updated_at := CURRENT_TIMESTAMP;
  ELSIF TG_TABLE_NAME = 'camera_permissions' THEN
    NEW.cap_updated_at := CURRENT_TIMESTAMP;
  ELSIF TG_TABLE_NAME = 'camera_detection_settings' THEN
    NEW.cds_updated_at := CURRENT_TIMESTAMP;
  ELSIF TG_TABLE_NAME = 'maintenance_history' THEN
    NEW.mnt_updated_at := CURRENT_TIMESTAMP;
  ELSIF TG_TABLE_NAME = 'alerts' THEN
    NEW.alr_updated_at := CURRENT_TIMESTAMP;
  ELSIF TG_TABLE_NAME = 'alert_note_history' THEN
    NEW.anh_updated_at := CURRENT_TIMESTAMP;
  ELSIF TG_TABLE_NAME = 'events' THEN
    NEW.evt_updated_at := CURRENT_TIMESTAMP;
  ELSIF TG_TABLE_NAME = 'global_detection_settings' THEN
    NEW.gds_updated_at := CURRENT_TIMESTAMP;
  END IF;
  RETURN NEW;
END;
$$;

-- (ถ้าต้องการ touch บนตาราง GDS เวลา UPDATE ด้วย)
DROP TRIGGER IF EXISTS trg_gds_touch_updated ON global_detection_settings;
CREATE TRIGGER trg_gds_touch_updated
BEFORE UPDATE ON global_detection_settings
FOR EACH ROW EXECUTE FUNCTION trg_touch_updated_at();

-- เมื่อมี Event ใหม่ ให้สร้าง GDS อัตโนมัติ (ใช้ค่า DEFAULT ของคอลัมน์)
CREATE OR REPLACE FUNCTION trg_after_events_insert_fill_gds()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
  INSERT INTO global_detection_settings (gds_evt_id)
  VALUES (NEW.evt_id)
  ON CONFLICT (gds_evt_id) DO NOTHING; -- กันซ้ำ (แม้รัน bulk insert พร้อมกัน)
  RETURN NEW;
END;
$$;

DROP TRIGGER IF EXISTS trg_events_after_insert_fill_gds ON events;
CREATE TRIGGER trg_events_after_insert_fill_gds
AFTER INSERT ON events
FOR EACH ROW EXECUTE FUNCTION trg_after_events_insert_fill_gds();

-- Bind BEFORE UPDATE
DROP TRIGGER IF EXISTS trg_users_touch_updated ON users;
CREATE TRIGGER trg_users_touch_updated BEFORE UPDATE ON users
FOR EACH ROW EXECUTE FUNCTION trg_touch_updated_at();

DROP TRIGGER IF EXISTS trg_roles_touch_updated ON roles;
CREATE TRIGGER trg_roles_touch_updated BEFORE UPDATE ON roles
FOR EACH ROW EXECUTE FUNCTION trg_touch_updated_at();

DROP TRIGGER IF EXISTS trg_cameras_touch_updated ON cameras;
CREATE TRIGGER trg_cameras_touch_updated BEFORE UPDATE ON cameras
FOR EACH ROW EXECUTE FUNCTION trg_touch_updated_at();

DROP TRIGGER IF EXISTS trg_cap_touch_updated ON camera_permissions;
CREATE TRIGGER trg_cap_touch_updated BEFORE UPDATE ON camera_permissions
FOR EACH ROW EXECUTE FUNCTION trg_touch_updated_at();

DROP TRIGGER IF EXISTS trg_cds_touch_updated ON camera_detection_settings;
CREATE TRIGGER trg_cds_touch_updated BEFORE UPDATE ON camera_detection_settings
FOR EACH ROW EXECUTE FUNCTION trg_touch_updated_at();

DROP TRIGGER IF EXISTS trg_mnt_touch_updated ON maintenance_history;
CREATE TRIGGER trg_mnt_touch_updated BEFORE UPDATE ON maintenance_history
FOR EACH ROW EXECUTE FUNCTION trg_touch_updated_at();

DROP TRIGGER IF EXISTS trg_alerts_touch_updated ON alerts;
CREATE TRIGGER trg_alerts_touch_updated BEFORE UPDATE ON alerts
FOR EACH ROW EXECUTE FUNCTION trg_touch_updated_at();

DROP TRIGGER IF EXISTS trg_anh_touch_updated ON alert_note_history;
CREATE TRIGGER trg_anh_touch_updated BEFORE UPDATE ON alert_note_history
FOR EACH ROW EXECUTE FUNCTION trg_touch_updated_at();

DROP TRIGGER IF EXISTS trg_events_touch_updated ON events;
CREATE TRIGGER trg_events_touch_updated BEFORE UPDATE ON events
FOR EACH ROW EXECUTE FUNCTION trg_touch_updated_at();


/* ============================================================
   ======  On cameras INSERT: defaults & CDS complete  ========
   ============================================================ */

CREATE OR REPLACE FUNCTION trg_after_cameras_insert_permissions()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
  INSERT INTO camera_permissions (cap_cam_id)
  VALUES (NEW.cam_id)
  ON CONFLICT (cap_cam_id) DO NOTHING;
  RETURN NEW;
END;
$$;

DROP TRIGGER IF EXISTS trg_cameras_after_insert_permissions ON cameras;
CREATE TRIGGER trg_cameras_after_insert_permissions
AFTER INSERT ON cameras
FOR EACH ROW EXECUTE FUNCTION trg_after_cameras_insert_permissions();


CREATE OR REPLACE FUNCTION trg_after_cameras_insert_fill_cds()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
  INSERT INTO camera_detection_settings (cds_evt_id, cds_cam_id)
  SELECT evt_id, NEW.cam_id FROM events
  ON CONFLICT (cds_evt_id, cds_cam_id) DO NOTHING;
  RETURN NEW;
END;
$$;

DROP TRIGGER IF EXISTS trg_cameras_after_insert_fill_cds ON cameras;
CREATE TRIGGER trg_cameras_after_insert_fill_cds
AFTER INSERT ON cameras
FOR EACH ROW EXECUTE FUNCTION trg_after_cameras_insert_fill_cds();


/* ============================================================
   =========  On events INSERT: fill CDS for all cams  =========
   ============================================================ */

CREATE OR REPLACE FUNCTION trg_after_events_insert_fill_cds()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
  INSERT INTO camera_detection_settings (cds_evt_id, cds_cam_id)
  SELECT NEW.evt_id, cam_id FROM cameras
  ON CONFLICT (cds_evt_id, cds_cam_id) DO NOTHING;
  RETURN NEW;
END;
$$;

DROP TRIGGER IF EXISTS trg_events_after_insert_fill_cds ON events;
CREATE TRIGGER trg_events_after_insert_fill_cds
AFTER INSERT ON events
FOR EACH ROW EXECUTE FUNCTION trg_after_events_insert_fill_cds();


/* ============================================================
   =========  On events INSERT: fill event_priority  ===========
   ============================================================ */

CREATE OR REPLACE FUNCTION trg_after_events_insert_fill_priority()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
  INSERT INTO event_priority (epr_evt_id, epr_priority)
  VALUES (NEW.evt_id, 'medium')
  ON CONFLICT (epr_evt_id) DO NOTHING;
  RETURN NEW;
END;
$$;

DROP TRIGGER IF EXISTS trg_events_after_insert_fill_priority ON events;
CREATE TRIGGER trg_events_after_insert_fill_priority
AFTER INSERT ON events
FOR EACH ROW EXECUTE FUNCTION trg_after_events_insert_fill_priority();

/* ============================================================
   =========    ===========
   ============================================================ */


CREATE OR REPLACE FUNCTION aods_dev_v3.fn_sync_cds_is_use()
RETURNS TRIGGER AS $$
BEGIN
  -- ปิดการใช้งาน: sync เป็น FALSE
  IF NEW.evt_is_use = FALSE THEN
    UPDATE aods_dev_v3.camera_detection_settings
    SET
      cds_is_use    = FALSE,
      cds_updated_at = CURRENT_TIMESTAMP
    WHERE cds_evt_id = NEW.evt_id
      AND cds_is_use IS DISTINCT FROM FALSE;

  -- เปิดการใช้งาน: sync กลับเป็น TRUE
  ELSIF NEW.evt_is_use = TRUE THEN
    UPDATE aods_dev_v3.camera_detection_settings
    SET
      cds_is_use    = TRUE,
      cds_updated_at = CURRENT_TIMESTAMP
    WHERE cds_evt_id = NEW.evt_id
      AND cds_is_use IS DISTINCT FROM TRUE;
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- สร้าง/แทนที่ Trigger ให้ชี้มาที่ฟังก์ชันด้านบน
DROP TRIGGER IF EXISTS trg_sync_cds_is_use ON aods_dev_v3.events;

CREATE TRIGGER trg_sync_cds_is_use
AFTER UPDATE OF evt_is_use ON aods_dev_v3.events
FOR EACH ROW
WHEN (OLD.evt_is_use IS DISTINCT FROM NEW.evt_is_use)
EXECUTE FUNCTION aods_dev_v3.fn_sync_cds_is_use();

-- ============================================================
-- INSERT BASE DATA
-- ============================================================

-- Roles (system=4, admin=3, security officer=2, staff=1)
INSERT INTO roles (rol_name, rol_access_level) VALUES
  ('system', 4),
  ('admin', 3),
  ('security officer', 2),
  ('staff', 1);

-- Users (ใส่ user system เป็นค่า default)
INSERT INTO users (usr_rol_id, usr_username, usr_email, usr_password) VALUES
  (4, 'test', 'test@example.com', 'test');
  
-- Locations (ตัวอย่าง)
INSERT INTO locations (loc_name) VALUES
  ('Head Office Main Gate'),
  ('Main Lobby'),
  ('Parking Lot A'),
  ('Server Room'),
  ('Warehouse Rear Exit');

-- Events (ใช้ชื่อ icon ของ Lucide)
INSERT INTO events (evt_icon, evt_name, evt_description) VALUES
  ('motion', 'Motion Detected', 'Detects movement in camera view'),
  ('shield-alert', 'Intrusion', 'Detects perimeter breach'),
  ('camera-off', 'Tamper', 'Detects camera tampering'),
  ('wifi-off', 'Offline', 'Detects camera offline');

  -- ===============================
-- Insert 10 Cameras (Example Data)
-- ===============================

INSERT INTO cameras (
  cam_created_by, cam_loc_id,
  cam_name, cam_source_type, cam_source_value,
  cam_type, cam_status, cam_description
) VALUES
(1, 1, 'Gate Entrance Cam 01', 'url', 'rtsp://192.168.1.10:554/live', 'fixed', TRUE, 'Covers main gate area'),
(1, 1, 'Gate Entrance Cam 02', 'url', 'rtsp://192.168.1.11:554/live', 'ptz', TRUE, 'PTZ camera for gate overview'),
(1, 2, 'Lobby Cam 01', 'url', 'rtsp://192.168.1.12:554/live', 'fixed', TRUE, 'Covers reception area'),
(1, 2, 'Lobby Cam 02', 'url', 'rtsp://192.168.1.13:554/live', 'fixed', TRUE, 'Side view of the main lobby'),
(1, 3, 'Parking A Cam 01', 'url', 'rtsp://192.168.1.14:554/live', 'panoramic', TRUE, 'Wide view of parking lot A'),
(1, 3, 'Parking A Cam 02', 'url', 'rtsp://192.168.1.15:554/live', 'fixed', TRUE, 'Entrance area of parking lot A'),
(1, 4, 'Server Room Cam 01', 'url', 'rtsp://192.168.1.16:554/live', 'thermal', TRUE, 'Thermal monitoring inside server room'),
(1, 4, 'Server Room Cam 02', 'url', 'rtsp://192.168.1.17:554/live', 'fixed', TRUE, 'Backup view for thermal camera'),
(1, 5, 'Warehouse Exit Cam 01', 'url', 'rtsp://192.168.1.18:554/live', 'fixed', TRUE, 'Rear exit of the warehouse'),
(1, 5, 'Warehouse Exit Cam 02', 'url', 'rtsp://192.168.1.19:554/live', 'ptz', TRUE, 'Covers full rear area');

-- ============================================================
-- Seed Footages (10 rows) -> อ้างอิง cameras.cam_id = 1..10
-- ============================================================
INSERT INTO footages (fgt_cam_id, fgt_path) VALUES
  (1,  '/videos/2025-10-27/cam01_motion_12-00-01.mp4'),
  (2,  '/videos/2025-10-27/cam02_intrusion_12-01-10.mp4'),
  (3,  '/videos/2025-10-27/cam03_tamper_12-02-20.mp4'),
  (4,  '/videos/2025-10-27/cam04_offline_12-03-30.mp4'),
  (5,  '/videos/2025-10-27/cam05_motion_12-04-40.mp4'),
  (6,  '/videos/2025-10-27/cam06_intrusion_12-05-50.mp4'),
  (7,  '/videos/2025-10-27/cam07_tamper_12-07-00.mp4'),
  (8,  '/videos/2025-10-27/cam08_offline_12-08-10.mp4'),
  (9,  '/videos/2025-10-27/cam09_motion_12-09-20.mp4'),
  (10, '/videos/2025-10-27/cam10_intrusion_12-10-30.mp4');

-- หมายเหตุ: ตารางเพิ่งถูก DROP/CREATE ใหม่
-- fgt_id จะเริ่มจาก 1..10 ตามลำดับแทรกข้างบน

-- ============================================================
-- Seed Alerts (10 rows) -> map cam_id 1..10, fgt_id 1..10, evt_id 1..4
-- events: 1=Motion Detected, 2=Intrusion, 3=Tamper, 4=Offline
-- alr_created_by ใช้ usr_id = 1 (user 'test')
-- ============================================================
INSERT INTO alerts (
  alr_created_by, alr_cam_id, alr_fgt_id, alr_evt_id,
  alr_severity, alr_status, alr_description, alr_reason, alr_created_at
) VALUES
  (1, 1,  1,  1, 'medium',  'active',   'Movement detected near main gate',               'Sensitivity threshold exceeded',        CURRENT_TIMESTAMP - INTERVAL '12 minutes'),
  (1, 2,  2,  2, 'high',    'active',   'Unauthorized entry detected at gate overview',   'ROI intrusion line crossed',            CURRENT_TIMESTAMP - INTERVAL '11 minutes'),
  (1, 3,  3,  3, 'high',    'active',   'Possible camera tampering in lobby',             'Camera angle changed abruptly',         CURRENT_TIMESTAMP - INTERVAL '10 minutes'),
  (1, 4,  4,  4, 'critical','active',   'Server Room Cam 02 went offline',                'Lost heartbeat > 60s',                  CURRENT_TIMESTAMP - INTERVAL '9 minutes'),
  (1, 5,  5,  1, 'low',     'resolved', 'Motion in Parking Lot A panoramic view',         'Short burst motion; auto-resolved',     CURRENT_TIMESTAMP - INTERVAL '8 minutes'),
  (1, 6,  6,  2, 'critical','active',   'Intrusion at Parking Lot A entrance',            'Multiple objects crossed boundary',     CURRENT_TIMESTAMP - INTERVAL '7 minutes'),
  (1, 7,  7,  3, 'medium',  'resolved', 'Thermal cam tamper suspicion in server room',    'Thermal image offset detected',         CURRENT_TIMESTAMP - INTERVAL '6 minutes'),
  (1, 8,  8,  4, 'high',    'dismissed','Intermittent offline event on backup camera',    'Network jitter; acknowledged by staff', CURRENT_TIMESTAMP - INTERVAL '5 minutes'),
  (1, 9,  9,  1, 'low',     'active',   'Motion near warehouse rear exit',                'Single person detected',                 CURRENT_TIMESTAMP - INTERVAL '4 minutes'),
  (1, 10, 10, 2, 'critical','active',   'Rear area perimeter breach detected',            'Continuous boundary violation',         CURRENT_TIMESTAMP - INTERVAL '3 minutes');

  -- ============================================================
-- Insert Maintenance History (1 record per camera)
-- ============================================================

INSERT INTO maintenance_history (
  mnt_cam_id, mnt_date, mnt_type, mnt_technician, mnt_note
) VALUES
  (1, '2025-10-10', 'routine check', 'Technician A', 'ตรวจเช็คกล้องประตูหลักและทำความสะอาดเลนส์'),
  (2, '2025-10-11', 'inspection', 'Technician B', 'ตรวจสอบการหมุนของกล้อง PTZ ปกติ'),
  (3, '2025-10-12', 'repair', 'Technician C', 'เปลี่ยนสาย LAN ที่ชำรุดในโซน Lobby'),
  (4, '2025-10-13', 'routine check', 'Technician D', 'เช็กภาพและระบบบันทึก Lobby Cam 02 ปกติ'),
  (5, '2025-10-14', 'upgrade', 'Technician E', 'อัปเกรด firmware กล้อง panoramic ล่าสุด'),
  (6, '2025-10-15', 'routine check', 'Technician F', 'ตรวจสอบสัญญาณ Parking A Cam 02'),
  (7, '2025-10-16', 'inspection', 'Technician G', 'ตรวจสอบอุณหภูมิกล้อง Thermal อยู่ในเกณฑ์ปกติ'),
  (8, '2025-10-17', 'repair', 'Technician H', 'เปลี่ยน adapter กล้อง Server Room Cam 02'),
  (9, '2025-10-18', 'routine check', 'Technician I', 'ตรวจเช็คเลนส์และโฟกัสกล้อง Warehouse Exit Cam 01'),
  (10,'2025-10-19', 'installation', 'Technician J', 'ติดตั้งกล้อง Warehouse Exit Cam 02 ใหม่หลังซ่อมบำรุง');
